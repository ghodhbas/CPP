#include "IO.h"

namespace IO{

    void import_OFF_file(Polyhedron& m, SurfaceMesh& surface, std::string filename) {
        std::cout << "READING TO POLYHEDRON" << std::endl;
        std::ifstream file(std::string("Meshes/").append(filename));
        if (!(file >> m)) {
            std::cerr << "cannot read mesh\n";
        }


        std::cout << "READING Surface Mesh File: " << filename << std::endl;
        std::ifstream file2(std::string("Meshes/").append(filename));
        if (!file2 || !(file2 >> surface)) {
            std::cerr << "cannot read surface\n";
        }
    }
    

     void import_OBJ_file(Polyhedron& m, std::string filename) {
         // Load OBJ
         std::vector<Kernel::Point_3> points_ref;
         std::vector<std::vector<std::size_t> > faces_ref;

         std::ifstream file(std::string("Meshes/").append(filename));
         if (!file || !CGAL::read_OBJ(file, points_ref, faces_ref))
         {
             std::cerr << "cannot read mesh";
             return;
         }

         namespace PMP = CGAL::Polygon_mesh_processing;
         PMP::orient_polygon_soup(points_ref, faces_ref); // optional if your mesh is not correctly oriented
         PMP::polygon_soup_to_polygon_mesh(points_ref, faces_ref, m);
     }


     //not FACES
     void write_PLY(std::string filename, SurfaceMesh& surface)
     {
         std::vector<PCI> points; // store points
         SurfaceMesh::Property_map<SurfaceMesh::Vertex_index, CGAL::Color> colors = surface.property_map<SurfaceMesh::Vertex_index, CGAL::Color >("v:color").first;
         for (SurfaceMesh::Vertex_index vi : surface.vertices())
         {

             points.push_back(std::make_tuple(surface.point(vi), CGAL::make_array((unsigned char)colors[vi][0], (unsigned char)colors[vi][1], (unsigned char)colors[vi][2], (unsigned char)colors[vi][3])));
         }

         std::ofstream f(filename);
         if (!f)
         {
             std::cerr << "Error: cannot open file" << std::endl;
             exit(1);
         }

         // Write header
         f << "ply" << std::endl
             << "format ascii 1.0" << std::endl
             << "comment Generated by Slim Ghodhbane" << std::endl
             << "element vertex " << points.size() << std::endl
             << "property double x" << std::endl
             << "property double y" << std::endl
             << "property double z" << std::endl
             << "property uchar red" << std::endl
             << "property uchar green" << std::endl
             << "property uchar blue" << std::endl
             << "property uchar alpha" << std::endl
             << "element face " << (unsigned int)surface.number_of_faces() << std::endl
             << "property list uchar int vertex_index" << endl
             << "end_header" << std::endl;

         //write point and colots
         for (unsigned int i = 0; i < points.size(); i++)
         {
             PCI p = points[i];
             f << std::get<0>(p).x() << " " << std::get<0>(p).y() << " " << std::get<0>(p).z() << " ";
             f << (int)std::get<1>(p)[0] << " " << (int)std::get<1>(p)[1] << " " << (int)std::get<1>(p)[2] << " " << (int)std::get<1>(p)[3] << endl;
         }


         //iterate over all faces and get their vetecies
         BOOST_FOREACH(boost::graph_traits<SurfaceMesh>::face_descriptor fd, faces(surface)) {
             string line = "";
             int nb_vertex_per_face = 0;
             for (SurfaceMesh::Vertex_index vd : vertices_around_face(surface.halfedge(fd), surface)) {
                 line.append(std::to_string(vd.idx()));
                 line.append(" ");
                 //f << vd.idx()<<" ";
                 nb_vertex_per_face += 1;
             }
             //cout << nb_vertex_per_face<< " " << line << endl;
             f << nb_vertex_per_face << " " << line << endl;
             //f << endl;
         }
         //f.close();

     }



     void write_PLY(std::string filename, std::vector< Kernel::Point_3> points)
     {

         std::ofstream f(filename);
         if (!f)
         {
             std::cerr << "Error: cannot open file" << std::endl;
             exit(1);
         }

         // Write header
         f << "ply" << std::endl
             << "format ascii 1.0" << std::endl
             << "comment Generated by Slim Ghodhbane" << std::endl
             << "element vertex " << points.size() << std::endl
             << "property double x" << std::endl
             << "property double y" << std::endl
             << "property double z" << std::endl
             << "end_header" << std::endl;

         //write point and colots
         for (unsigned int i = 0; i < points.size(); i++)
         {

             f << points[i].x() << " " << points[i].y() << " " << points[i].z() << endl;
         }
         f.close();

     }


     void write_PLY(std::string filename, vector< Eigen::Vector3f> path)
     {

         std::ofstream f(filename);
         if (!f)
         {
             std::cerr << "Error: cannot open file" << std::endl;
             exit(1);
         }

         // Write header
         f << "ply" << std::endl
             << "format ascii 1.0" << std::endl
             << "comment Generated by Slim Ghodhbane" << std::endl
             << "element vertex " << path.size() << std::endl
             << "property float x" << std::endl
             << "property float y" << std::endl
             << "property float z" << std::endl
             << "element edge "<< path.size()-1 << std::endl
             << "property int vertex1" << std::endl
             << "property int vertex2" << std::endl
             << "end_header" << std::endl;

         //write point and colots
         for (unsigned int i = 0; i < path.size(); i++)
         {

             f << path[i].x() << " " << path[i].y() << " " << path[i].z() << endl;
         }

         for (size_t i = 0; i < path.size()-1; i++)
         {
             f << i<< " " << (i+1) << endl;
         }
         f.close();

     }


     void write_OFF(std::string filename, SurfaceMesh& surface)
     {
         std::vector<PCI> points; // store points
         SurfaceMesh::Property_map<SurfaceMesh::Vertex_index, CGAL::Color> colors = surface.property_map<SurfaceMesh::Vertex_index, CGAL::Color >("v:color").first;
         for (SurfaceMesh::Vertex_index vi : surface.vertices())
         {

             points.push_back(std::make_tuple(surface.point(vi), CGAL::make_array((unsigned char)colors[vi][0], (unsigned char)colors[vi][1], (unsigned char)colors[vi][2], (unsigned char)colors[vi][3])));
         }

         std::ofstream f(filename);
         if (!f)
         {
             std::cerr << "Error: cannot open file" << std::endl;
             exit(1);
         }

         // Write header
         f << "COFF" << std::endl
             << points.size() << " " << (unsigned int)surface.number_of_faces() << " " << (unsigned int)surface.number_of_edges() << std::endl;

         //write point and colots
         for (unsigned int i = 0; i < points.size(); i++)
         {
             PCI p = points[i];
             f << std::get<0>(p).x() << " " << std::get<0>(p).y() << " " << std::get<0>(p).z() << " ";
             f << (int)std::get<1>(p)[0] << " " << (int)std::get<1>(p)[1] << " " << (int)std::get<1>(p)[2] << " " << (int)std::get<1>(p)[3] << endl;
         }


         //iterate over all faces and get their vetecies
         BOOST_FOREACH(boost::graph_traits<SurfaceMesh>::face_descriptor fd, faces(surface)) {
             string line = "";
             int nb_vertex_per_face = 0;
             for (SurfaceMesh::Vertex_index vd : vertices_around_face(surface.halfedge(fd), surface)) {
                 line.append(std::to_string(vd.idx()));
                 line.append(" ");
                 //f << vd.idx()<<" ";
                 nb_vertex_per_face += 1;
             }
             //cout << nb_vertex_per_face<< " " << line << endl;
             f << nb_vertex_per_face << " " << line << endl;
             //f << endl;
         }
         f.close();
     }


}
